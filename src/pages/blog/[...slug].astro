---
import BlogPost from '../../components/layout/MarkdownPost.astro';
import { supabase } from '../../utils/supabaseClient';
import type { PostFrontmatter } from '../../utils/types';
// Using unified for manual processing
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeStringify from 'rehype-stringify';
// Note: We are processing as Markdown -> HTML. If MDX features are needed, remark-mdx and different rehype plugins might be required.
// import {matter} from 'vfile-matter';
// import parse from 'js-yaml';
// import remarkFrontmatter from 'remark-frontmatter';

// Removed prerender = true; as it conflicts with dynamic rendering
// export const prerender = true; 

// Removed getStaticPaths as it's ignored in server mode for this page
/*
export async function getStaticPaths() {
    // ... (previous code) ...
}
*/
    const { data: posts, error } = await supabase
        .from('posts')
        .select('slug');

    //console.log("getStaticPaths: Posts from Supabase:", posts); //  LOG - Data de Supabase (lista de posts)

    if (error) {
        console.error("getStaticPaths: Error al obtener slugs de posts de Supabase:", error); // LOG Error Supabase
        return [];
    }

    if (!posts) {
        console.log("getStaticPaths: No se encontraron posts en Supabase."); // LOG No posts encontrados
        return [];
    }

    const paths = posts.map((post) => {
        //console.log("getStaticPaths: Procesando post:", post, "Slug:", post.slug); // LOG - Post individual y slug
        const slugValue = post.slug; // Extrae el slug
        //console.log("getStaticPaths: Slug:", slugValue); // LOG - Valor del slug extra√≠do
        return {
            params: { slug: slugValue }, // Usa slugValue para params
            props: { slug: slugValue },
        };
    });

    //console.log("getStaticPaths: Rutas generadas:", paths); // LOG - Rutas finales generadas
// Removed Props type definition as slug comes from Astro.params

// Get slug from Astro.params instead of Astro.props
const { slug } = Astro.params;

console.log(`[...slug].astro: Rendering page for slug: ${slug}`); // Log slug being processed

let postData = null;


if (slug) {
    const { data: post, error } = await supabase
        .from('posts')
        .select('*')
        .eq('slug', slug)
        .single();

    if (error) {
        console.error(`Error al obtener el post con slug '${slug}' de Supabase:`, error);
        throw new Error(`Error al cargar el post: ${slug}`);
    }

    // Process the fetched Markdown content into HTML using unified
    if (post && post.contenido) {
        const file = await unified()
            .use(remarkParse) // Parse Markdown
            .use(remarkRehype) // Convert Markdown AST to HTML AST
            .use(rehypeStringify) // Convert HTML AST to HTML string
            .process(post.contenido);

        postData = {
            // Pass the processed HTML content
            htmlContent: String(file.value), 
            frontmatter: post.metadata as PostFrontmatter || {}
        };
    } else if (post) {
         // Handle case where post exists but content is empty/null
         postData = {
            htmlContent: '', 
            frontmatter: post.metadata as PostFrontmatter || {}
         };
         console.log(`[...slug].astro: Post found for slug '${slug}', but content is empty.`); // Log if content is empty
    } else {
      // Log if post is not found at all
      console.log(`[...slug].astro: No post found in Supabase for slug '${slug}'.`);
    }
}


// Use htmlContent which was generated by unified
const { frontmatter, htmlContent } = postData || { frontmatter: null, htmlContent: "" };

---
{/* Using set:html with the processed htmlContent */}
<BlogPost
  title={frontmatter?.title ?? 'Default Title'}
  description={frontmatter?.description ?? 'Default Description'}
  image={frontmatter?.image ?? { url: '', alt: '' }}
  author={frontmatter?.author ?? 'Unknown Author'}
  pubDate={frontmatter?.pubDate ? new Date(frontmatter.pubDate) : new Date()}
  tags={frontmatter?.tags ?? []}
  {...frontmatter} 
>
  {/* Pass the pre-rendered HTML content via the slot using set:html */}
  <Fragment set:html={htmlContent} />
</BlogPost>
