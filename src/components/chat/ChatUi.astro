---
import { trackChatbotInteraction } from '../../utils/trackChatbotInteraction';
---

<div class="fixed bottom-4 right-4 z-[999]">
  <!-- Botón toggle -->
  <button
    id="chatbot-toggle"
    class="w-14 h-14 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full shadow-xl cursor-pointer transition-all duration-300 hover:scale-110 flex items-center justify-center"
    aria-label="Abrir chat"
  >
    <svg class="w-6 h-6 text-white transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
    </svg>
  </button>

  <!-- Contenedor del Chat -->
  <div
    id="chatbot-container"
    class="fixed bottom-20 right-4 w-[95vw] md:w-96 h-[70vh] bg-gray-900 backdrop-blur-lg bg-opacity-95 text-white rounded-xl shadow-2xl opacity-0 translate-y-4 scale-95 origin-bottom-right transition-all duration-300 border border-white/10 pointer-events-none"
  >
    <div class="flex flex-col h-full pointer-events-auto">
      <!-- Header -->
      <div class="bg-gradient-to-r from-blue-600/30 to-purple-600/30 p-4 rounded-t-xl flex justify-between items-center">
        <h3 class="font-bold text-lg">Asistente Virtual</h3>
        <button
          id="close-chat"
          class="p-1 hover:text-blue-400 transition-colors"
          aria-label="Cerrar chat"
        >
          <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>

      <!-- Área de mensajes -->
      <div
        id="chat-messages"
        class="flex-1 overflow-y-auto p-4 space-y-4 text-sm scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent"
      >
        <!-- Mensaje inicial -->
        <div class="bot-message flex justify-start">
          <div class="bg-gray-800/80 rounded-xl p-3 max-w-[85%]">
            ¡Hola! ¿En qué puedo ayudarte hoy?
          </div>
        </div>
      </div>

      <!-- Indicador de estado -->
      <div
        id="status-indicator"
        class="flex items-center gap-2 px-4 pb-2 text-xs text-gray-400 opacity-0 transition-opacity duration-200"
      >
        <div class="spinner animate-spin h-4 w-4 border-2 border-white/50 border-t-transparent rounded-full"></div>
        <span>Generando respuesta...</span>
      </div>

      <!-- Input de usuario -->
      <div class="border-t border-white/10 p-4 bg-gray-900/50">
        <div class="flex gap-2">
          <input
            id="user-input"
            type="text"
            placeholder="Escribe tu pregunta..."
            class="flex-1 bg-gray-800/70 border border-white/10 rounded-lg px-4 py-3 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all"
            aria-label="Escribe tu mensaje"
          />
          <button
            id="send-btn"
            class="bg-blue-600 hover:bg-blue-700 px-4 rounded-lg transition-colors flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed"
            aria-label="Enviar mensaje"
            disabled
          >
            <svg class="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  /* Animaciones personalizadas */
  @keyframes messagePop {
    0% { transform: scale(0.8); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
  }

  @keyframes typing {
    0%, 80%, 100% { transform: translateY(0); }
    30% { transform: translateY(-6px); }
  }

  .message-enter {
    animation: messagePop 0.3s ease-out;
  }

  .typing-indicator {
    display: inline-flex;
    gap: 4px;
    padding: 0.5rem 1rem;
  }

  .typing-dot {
    width: 6px;
    height: 6px;
    background: #94a3b8;
    border-radius: 50%;
    animation: typing 1.4s infinite ease-in-out;
  }

  /* Scrollbar personalizada */
  .scrollbar-thumb-gray-700::-webkit-scrollbar-thumb {
    background-color: #374151;
    border-radius: 0.5rem;
  }
</style>

<script>
  // Constantes movidas al cliente
  const API_ENDPOINT = '/api/query';
  const MAX_HISTORY_LENGTH = 20;
  const LOCAL_STORAGE_KEY = 'chatHistory';
  const RETRY_CONFIG = {
    maxRetries: 2,
    baseDelay: 1000
  };

  // Interfaces de TypeScript
  interface Message {
    role: 'user' | 'assistant' | 'error';
    content: string;
    sources?: Array<{ title: string }>;
  }

  interface ChatState {
    isOpen: boolean;
    history: Message[];
    controller: AbortController | null;
  }

  let chatState: ChatState = {
    isOpen: false,
    history: [],
    controller: null,
  };

  /* Elementos del DOM */
  const elements = {
    toggleButton: document.getElementById('chatbot-toggle'),
    container: document.getElementById('chatbot-container'),
    closeButton: document.getElementById('close-chat'),
    messagesContainer: document.getElementById('chat-messages'),
    input: document.getElementById('user-input') as HTMLInputElement | null,
    sendButton: document.getElementById('send-btn') as HTMLButtonElement | null,
    statusIndicator: document.getElementById('status-indicator'),
  };

  /* Utilidades principales */
  const utils = {
    // Sanitiza y formatea markdown básico
    formatContent: (text: string) => {
      const sanitized = document.createElement('div');
      sanitized.textContent = text;
      return sanitized.innerHTML
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
        .replace(/`(.*?)`/g, '<code>$1</code>')
        .replace(/\n/g, '<br>');
    },

    // Registra eventos en consola
    log: (type: string, message: string, data?: any) => {
      const timestamp = new Date().toISOString();
      console.log(`[${timestamp} [${type.toUpperCase()}] ${message}`, data || '');
    },
  };

  /* Manejo de la interfaz */
  const ui = {
    // Alternar visibilidad del chat
    toggleChat: () => {
      chatState.isOpen = !chatState.isOpen;
      elements.container?.classList.toggle('opacity-0', !chatState.isOpen);
      elements.container?.classList.toggle('translate-y-4', !chatState.isOpen);
      elements.container?.classList.toggle('scale-95', !chatState.isOpen);
      if (elements.container) {
        elements.container.style.pointerEvents = chatState.isOpen ? 'auto' : 'none';
      }
      elements.toggleButton?.classList.toggle('rotate-45', chatState.isOpen);
    },

    // Agregar nuevo mensaje al historial
    addMessage: (role: string, content: string, sources: { title: string }[] = []) => {
      const messageElement = document.createElement('div');
      messageElement.className = `${role}-message flex justify-${role === 'user' ? 'end' : 'start'} message-enter`;

      const bubbleClass = role === 'error'
        ? 'bg-red-600/20 text-red-400 border border-red-600/30'
        : role === 'user'
          ? 'bg-blue-600/80'
          : 'bg-gray-800/80';

      const sourcesHTML = sources.length > 0
        ? `<div class="mt-2 pt-2 border-t border-white/10 text-xs text-gray-400">
            <div class="font-medium mb-1">Fuentes:</div>
            ${sources.map(s => `<div class="truncate">${s.title}</div>`).join('')}
           </div>`
        : '';

      messageElement.innerHTML = `
        <div class="${bubbleClass} rounded-xl p-3 max-w-[85%]">
          ${utils.formatContent(content)}
          ${sourcesHTML}
        </div>
      `;

      elements.messagesContainer?.appendChild(messageElement);
      if (elements.messagesContainer) {
          elements.messagesContainer.scrollTop = elements.messagesContainer.scrollHeight;
      }
    },

    // Mostrar estado de carga
    toggleLoading: (isLoading: boolean) => {
      if (elements.statusIndicator) {
        elements.statusIndicator.style.opacity = isLoading ? '1' : '0';
      }
      if (elements.sendButton) {
        elements.sendButton.disabled = isLoading;
      }
      if (elements.input) {
        elements.input.disabled = isLoading;
      }
    },
  };

  /* Manejo de API */
  const api = {
    // Enviar consulta con reintentos
    sendQuery: async (query: string) => {
      if (chatState.controller) {
        chatState.controller.abort();
      }
      chatState.controller = new AbortController();

      let retries = RETRY_CONFIG.maxRetries;
      while (retries >= 0) {
        try {
          // Usar RETRY_CONFIG.baseDelay aquí
          await new Promise(resolve =>
            setTimeout(resolve, RETRY_CONFIG.baseDelay * (RETRY_CONFIG.maxRetries - retries + 1))
          );
          const response = await fetch(API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              query,
              history: chatState.history.slice(-4)
            }),
            signal: chatState.controller.signal,
          });

          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          return await response.json();

        } catch (error: any) {
          if (retries === 0 || error.name === 'AbortError') throw error;

          await new Promise(resolve =>
            setTimeout(resolve, RETRY_CONFIG.baseDelay * (RETRY_CONFIG.maxRetries - retries + 1))
          );
          retries--;
          utils.log('warn', `Reintentando... (${RETRY_CONFIG.maxRetries - retries}/${RETRY_CONFIG.maxRetries})`);
        }
      }
      throw new Error('Max retries reached'); // If all retries failed, throw an error
    },
  };

  /* Manejo del historial */
  const history = {
    // Cargar historial desde localStorage
    load: () => {
      try {
        const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
        return saved ? JSON.parse(saved) : [];
      } catch (error: any) {
        utils.log('error', 'Error cargando historial', error);
        return [];
      }
    },

    // Guardar historial en localStorage
    save: () => {
      try {
        const limited = chatState.history.slice(-MAX_HISTORY_LENGTH);
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(limited));
      } catch (error: any) {
        utils.log('error', 'Error guardando historial', error);
      }
    },
  };

  /* Inicialización */
  const init = () => {
    // Configurar eventos
    elements.toggleButton?.addEventListener('click', ui.toggleChat);
    elements.closeButton?.addEventListener('click', ui.toggleChat);
    elements.input?.addEventListener('input', (e) => {
      if (elements.sendButton && e.target instanceof HTMLInputElement) {
        elements.sendButton.disabled = e.target.value.trim() === '';
      }
    });

    elements.sendButton?.addEventListener('click', async () => {
      if (!elements.input) return; // Exit if input is not available
      const query = elements.input.value.trim();
      if (!query) return;

      try {
        ui.toggleLoading(true);

        // Agregar mensaje de usuario
        chatState.history.push({ role: 'user', content: query });
        ui.addMessage('user', query);

        // Mostrar indicador de typing
        ui.addMessage('assistant', '<div class="typing-indicator"><div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div></div>');

        // Obtener respuesta
        const { response, sources, error } = await api.sendQuery(query);

        // Eliminar typing indicator (Find and remove.  It might be better to create a specific ID for it when you create it.)
        const typingIndicators = document.querySelectorAll(".typing-indicator");
        typingIndicators.forEach(indicator => indicator.remove());


        if (error) {
          ui.addMessage('error', error);
        } else {
          chatState.history.push({ role: 'assistant', content: response });
          ui.addMessage('assistant', response, sources);
          history.save();

          /* Función de tracking modificada */
          const trackInteraction = async (params: {
            userId: string;
            userQuery: string;
            botResponse: string;
            interactionType: string;
          }) => {
            try {
              await fetch('/api/track', {
                method: 'POST',
                body: JSON.stringify(params)
              });
            } catch (error) {
              console.error('Tracking error:', error);
            }
          };
        }

      } catch (error: any) {
        ui.addMessage('error', error.message || 'Error de conexión');
        utils.log('error', 'Error en flujo de chat', error);
      } finally {
        ui.toggleLoading(false);
        if(elements.input) {
          elements.input.value = '';
        }
      }
    });

    // Cargar historial
    chatState.history = history.load();
    chatState.history
      .filter(msg => msg.role === 'user')
      .forEach(msg => ui.addMessage(msg.role, msg.content));
  };

  // Iniciar cuando el DOM esté listo
  window.addEventListener('DOMContentLoaded', init);
</script>