---
title: "Estructuras de Datos en Python: Listas, Tuplas, Diccionarios, Conjuntos y Comprehensions"
description: "Aprende a utilizar las estructuras de datos fundamentales en Python: listas, tuplas, diccionarios, conjuntos y comprehensions para manipular datos de manera eficiente."
---

import { Card, CardGrid  } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';

<CardGrid>
  <Card title="¬°Organiza tus Datos!" icon="layout-grid">
    Descubre las estructuras de datos que te permiten organizar y manipular informaci√≥n de manera eficiente.
  </Card>
  <Card title="Flexibilidad y Poder" icon="rocket">
    Explora las operaciones, usos y ventajas de cada estructura de datos.
  </Card>
</CardGrid>

<Aside type="note" title="Importante üìù">
   Elegir la estructura de datos adecuada es clave para la eficiencia y claridad de tu c√≥digo.
</Aside>

# Estructuras de Datos en Python: El Arte de Organizar la Informaci√≥n

En este post, exploraremos en detalle las estructuras de datos fundamentales en Python. Estas estructuras son esenciales para organizar, almacenar y manipular datos de manera eficiente. Cubriremos:

1.  **Listas y Operaciones:** Secuencias mutables y vers√°tiles.
2.  **Tuplas y su Inmutabilidad:**  Secuencias inmutables para datos fijos.
3.  **Diccionarios y Casos de Uso:** Almacenamiento clave-valor para datos asociados.
4.  **Conjuntos y Operaciones de Conjuntos:**  Colecciones √∫nicas de elementos para operaciones matem√°ticas.
5.  **Comprehensions (List, Dict, Set):**  Forma concisa de crear estructuras de datos.

## 1. Listas y Operaciones <Badge text="Secuencias Mutables" variant="tip" />

Las listas son secuencias ordenadas y mutables de elementos. Pueden contener elementos de diferentes tipos y se definen usando corchetes `[]`.

```python
mi_lista = [1, 2, 3, "a", "b", 3.14]
lista_vacia = []
lista_anidada = [1, 2, [3, 4]]
```

### Operaciones Comunes con Listas

*   **Acceso por √≠ndice:**  Accede a elementos individuales usando su √≠ndice (empezando en 0).

    ```python
    print(mi_lista[0])   # 1
    print(mi_lista[-1])  # 3.14 (√∫ltimo elemento)
    ```

*   **Slicing:**  Obt√©n sublistas utilizando rangos de √≠ndices.

    ```python
    print(mi_lista[1:4])    # [2, 3, 'a']
    print(mi_lista[:3])     # [1, 2, 3]
    print(mi_lista[2:])     # [3, 'a', 'b', 3.14
    ```

*   **Modificaci√≥n de elementos:** Cambia el valor de un elemento por su √≠ndice.

    ```python
    mi_lista[0] = 10
    print(mi_lista)   # [10, 2, 3, 'a', 'b', 3.14]
    ```

*   **Agregar elementos:**

    *   `append(elemento)`: Agrega un elemento al final.
    *   `insert(indice, elemento)`: Agrega un elemento en una posici√≥n espec√≠fica.
    *   `extend(otra_lista)`: Agrega todos los elementos de otra lista al final.

    ```python
    mi_lista.append("c")
    mi_lista.insert(2, "z")
    mi_lista.extend([4, 5)
    print(mi_lista)  # [10, 2, 'z', 3, 'a', 'b', 3.14, 'c', 4, 5]
    ```

*   **Eliminar elementos:**

    *   `remove(elemento)`: Elimina la primera aparici√≥n del elemento.
    *   `pop(indice)`: Elimina el elemento en una posici√≥n espec√≠fica (retorna el elemento).
    *   `del lista[indice]`: Elimina el elemento en una posici√≥n espec√≠fica.
    *   `clear()`: Elimina todos los elementos de la lista.

    ```python
    mi_lista.remove("z")
    elemento_eliminado = mi_lista.pop(0)
    del mi_lista[1]
    print(mi_lista) # [2, 'a', 'b', 3.14, 'c', 4, 5]

    mi_lista.clear() # []
    ```

*   **Ordenar listas:**

    *   `sort()`: Ordena la lista in-place (modifica la lista).
    *   `sorted(lista)`: Retorna una nueva lista ordenada.

    ```python
    numeros = [3, 1, 4, 1, 5, 9, 2, 6]
    numeros.sort() # modifica la lista
    print(numeros)  # [1, 1, 2, 3, 4, 5, 6, 9]
    numeros_ordenados = sorted([3, 1, 4, 1, 5, 9, 2, 6]) # retorna una lista nueva ordenada
     print(numeros_ordenados) # [1, 1, 2, 3, 4, 5, 6, 9]
    ```

*   **Otras operaciones:**
    *   `len(lista)`: Retorna el n√∫mero de elementos.
    *   `lista.count(elemento)`: Retorna el n√∫mero de veces que un elemento aparece en la lista.
    *   `lista.index(elemento)`: Retorna el √≠ndice de la primera aparici√≥n del elemento.
    *   `in` :  Verifica si un elemento est√° en la lista
    ```python
    print(len(numeros))   # 8
    print(numeros.count(1)) # 2
    print(numeros.index(6)) # 6
    print (1 in numeros)  # True
    ```

## 2. Tuplas y su Inmutabilidad <Badge text="Secuencias Inmutables" variant="note" />

Las tuplas son secuencias ordenadas e inmutables de elementos. Se definen usando par√©ntesis `()` y no se pueden modificar una vez creadas.

```python
mi_tupla = (1, 2, 3, "a", "b")
tupla_vacia = ()
tupla_un_elemento = (5,) # la coma indica que es tupla
```

### Ventajas de las Tuplas
*   **Inmutabilidad:** Garantiza que los datos no se cambien accidentalmente.
*   **Eficiencia:** Las tuplas suelen ser m√°s eficientes en memoria y acceso que las listas.
*   **Hashability:** Las tuplas pueden usarse como claves en diccionarios (las listas no).

### Operaciones con Tuplas
Las tuplas admiten las mismas operaciones de acceso y slicing que las listas, pero no las operaciones que modifican la tupla (como append, insert, remove, etc).

```python
print(mi_tupla[0])      # 1
print(mi_tupla[1:4])    # (2, 3, 'a')
```

### Uso Com√∫n de Tuplas
*   Representar registros (por ejemplo, coordenadas x, y, z).
*   Retornar m√∫ltiples valores desde una funci√≥n.
*   Almacenar datos que no deber√≠an cambiar.

## 3. Diccionarios y Casos de Uso <Badge text="Almacenamiento Clave-Valor" variant="success" size="large" />

Los diccionarios son colecciones no ordenadas de pares clave-valor. Se definen usando llaves `{}` y las claves deben ser √∫nicas e inmutables (strings, n√∫meros, tuplas).

```python
mi_diccionario = {
    "nombre": "Juan",
    "edad": 30,
    "ciudad": "Madrid"
}

diccionario_vacio = {}
```

### Operaciones con Diccionarios

*   **Acceso por clave:** Accede al valor usando la clave.

    ```python
    print(mi_diccionario["nombre"])  # Juan
    print(mi_diccionario.get("edad")) # 30
    ```

*   **Agregar o modificar pares clave-valor:**

    ```python
    mi_diccionario["profesion"] = "Programador"
    mi_diccionario["edad"] = 31
    print(mi_diccionario) # {'nombre': 'Juan', 'edad': 31, 'ciudad': 'Madrid', 'profesion': 'Programador'}
    ```
*   **Eliminar pares clave-valor:**

    *   `del diccionario[clave]`: Elimina un elemento por su clave
    *   `pop(clave)`: Elimina un elemento por su clave y retorna el elemento
    *   `popitem()`: Elimina y retorna el √∫ltimo par clave-valor ingresado en el diccionario (En versiones anteriores a Python 3.7 elimina un par aleatorio).
    *   `clear()`: Elimina todos los elementos del diccionario

    ```python
    del mi_diccionario["ciudad"]
    print(mi_diccionario) # {'nombre': 'Juan', 'edad': 31, 'profesion': 'Programador'}

    elemento_eliminado = mi_diccionario.pop("profesion")
    print(mi_diccionario) # {'nombre': 'Juan', 'edad': 31}

    mi_diccionario.popitem() # {'nombre': 'Juan'}

    mi_diccionario.clear() # {}
    ```

*   **Recorrer diccionarios:**
    * `keys()`: Retorna una lista con las claves del diccionario
    * `values()`: Retorna una lista con los valores del diccionario
    * `items()`: Retorna una lista de tuplas (clave, valor) del diccionario

    ```python
    mi_diccionario = {
      "nombre": "Juan",
      "edad": 30,
      "ciudad": "Madrid"
    }
    print(mi_diccionario.keys()) # ['nombre', 'edad', 'ciudad']
    print(mi_diccionario.values()) # ['Juan', 30, 'Madrid']
    print(mi_diccionario.items()) # [('nombre', 'Juan'), ('edad', 30), ('ciudad', 'Madrid')]
    ```
### Casos de Uso de Diccionarios
*   Almacenar informaci√≥n asociada (por ejemplo, datos de un usuario).
*   Contar ocurrencias de elementos.
*   Implementar caches.
*   Representar datos estructurados (por ejemplo, JSON).

## 4. Conjuntos y Operaciones de Conjuntos <Badge text="Colecciones √önicas" variant="note" />

Los conjuntos son colecciones no ordenadas y √∫nicas de elementos. Se definen usando llaves `{}` o la funci√≥n `set()`.

```python
mi_conjunto = {1, 2, 3, 4, 2} # Los duplicados se eliminan
conjunto_vacio = set() # usar set() para crear conjuntos vacios
```

### Operaciones de Conjuntos
*   **Uni√≥n (`|` o `union()`):** Retorna un nuevo conjunto con todos los elementos de ambos conjuntos.
*   **Intersecci√≥n (`&` o `intersection()`):** Retorna un nuevo conjunto con los elementos en com√∫n de ambos conjuntos.
*   **Diferencia (`-` o `difference()`):** Retorna un nuevo conjunto con los elementos del primer conjunto que no est√°n en el segundo.
*   **Diferencia Sim√©trica (`^` o `symmetric_difference()`):** Retorna un nuevo conjunto con los elementos que est√°n en un conjunto u otro, pero no en ambos.
*   **Agregar elementos:**
    *   `add(elemento)`: Agrega un elemento al conjunto (si no existe).
    *   `update(otro_conjunto)`: Agrega todos los elementos de otro conjunto.
*   **Eliminar elementos:**
    *   `remove(elemento)`: Elimina un elemento (lanza error si no existe).
    *   `discard(elemento)`: Elimina un elemento (no lanza error si no existe).
    *   `pop()`: Elimina y retorna un elemento arbitrario.
    *   `clear()`: Elimina todos los elementos del conjunto.

```python
conjunto1 = {1, 2, 3, 4}
conjunto2 = {3, 4, 5, 6}

print(conjunto1 | conjunto2) # {1, 2, 3, 4, 5, 6}
print(conjunto1 & conjunto2) # {3, 4}
print(conjunto1 - conjunto2) # {1, 2}
print(conjunto1 ^ conjunto2) # {1, 2, 5, 6}

conjunto1.add(5)
conjunto1.update({7,8})
print(conjunto1) # {1, 2, 3, 4, 5, 7, 8}

conjunto1.remove(8)
conjunto1.discard(9)
print(conjunto1)  # {1, 2, 3, 4, 5, 7}
conjunto1.pop()
print(conjunto1)  # {2, 3, 4, 5, 7}
conjunto1.clear()
print(conjunto1) # set()
```

### Uso Com√∫n de Conjuntos

*   Eliminar duplicados de listas.
*   Realizar operaciones matem√°ticas de conjuntos (uni√≥n, intersecci√≥n, etc).
*   Verificar la pertenencia de un elemento de manera eficiente.

## 5. Comprehensions (List, Dict, Set) <Badge text="Creaci√≥n Concisa" variant="tip" />

Las comprehensions son una forma concisa de crear listas, diccionarios y conjuntos. Ofrecen una sintaxis m√°s legible y eficiente.

### List Comprehensions
```python
cuadrados = [x**2 for x in range(5)] #[0, 1, 4, 9, 16]
pares = [x for x in range(10) if x % 2 == 0] #[0, 2, 4, 6, 8]
```

### Dict Comprehensions
```python
cuadrados_dict = {x: x**2 for x in range(5)} # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

### Set Comprehensions
```python
cuadrados_set = {x**2 for x in range(5)} # {0, 1, 4, 9, 16}
```

<Aside type="caution" title="Precauci√≥n ‚ö†Ô∏è">
   Aunque las comprehensions son poderosas, no las uses en exceso. Mant√©n tu c√≥digo legible.
</Aside>

## Conclusi√≥n

Las estructuras de datos son la base para manipular informaci√≥n en Python. En este post, exploramos listas, tuplas, diccionarios, conjuntos y comprehensions. ¬°Ahora tienes las herramientas para organizar tus datos de manera eficiente!

<Badge text="¬°Sigue Practicando!" variant="success" size="large" />

En el pr√≥ximo post, exploraremos el control de flujo.

import { LinkButton } from '@astrojs/starlight/components';

<LinkButton
  href="/docs/Python-Master-Course/intro"
  variant="primary"
  icon="arrow-left"
  iconPlacement="start"
>
  Volver al Inicio del Curso
</LinkButton>